// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package blockchain

import (
	"sync"
)

var (
	lockBlockHandlerMockHandleBlock sync.RWMutex
)

// BlockHandlerMock is a mock implementation of BlockHandler.
//
//     func TestSomethingThatUsesBlockHandler(t *testing.T) {
//
//         // make and configure a mocked BlockHandler
//         mockedBlockHandler := &BlockHandlerMock{
//             HandleBlockFunc: func(in1 *Block)  {
// 	               panic("TODO: mock out the HandleBlock method")
//             },
//         }
//
//         // TODO: use mockedBlockHandler in code that requires BlockHandler
//         //       and then make assertions.
//
//     }
type BlockHandlerMock struct {
	// HandleBlockFunc mocks the HandleBlock method.
	HandleBlockFunc func(in1 *Block)

	// calls tracks calls to the methods.
	calls struct {
		// HandleBlock holds details about calls to the HandleBlock method.
		HandleBlock []struct {
			// In1 is the in1 argument value.
			In1 *Block
		}
	}
}

// HandleBlock calls HandleBlockFunc.
func (mock *BlockHandlerMock) HandleBlock(in1 *Block) {
	if mock.HandleBlockFunc == nil {
		panic("BlockHandlerMock.HandleBlockFunc: method is nil but BlockHandler.HandleBlock was just called")
	}
	callInfo := struct {
		In1 *Block
	}{
		In1: in1,
	}
	lockBlockHandlerMockHandleBlock.Lock()
	mock.calls.HandleBlock = append(mock.calls.HandleBlock, callInfo)
	lockBlockHandlerMockHandleBlock.Unlock()
	mock.HandleBlockFunc(in1)
}

// HandleBlockCalls gets all the calls that were made to HandleBlock.
// Check the length with:
//     len(mockedBlockHandler.HandleBlockCalls())
func (mock *BlockHandlerMock) HandleBlockCalls() []struct {
	In1 *Block
} {
	var calls []struct {
		In1 *Block
	}
	lockBlockHandlerMockHandleBlock.RLock()
	calls = mock.calls.HandleBlock
	lockBlockHandlerMockHandleBlock.RUnlock()
	return calls
}
